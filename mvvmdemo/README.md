LiveData 为什么能解决上述这些问题？
首先，LiveData 是在 Google 希望确立 标准化、规范化 的开发模式 —— 这样一种背景下诞生的，
因而为了达成这个艰巨的 使命，LiveData 被十分克制地设计为，仅支持状态的输入和监听，并且可基于 “访问权限控制” 来实现 “读写分离”。

这使得任何一次数据推送，都可被限制为 “只能单方面地从唯一可信源推送而来”，从而避免了消息同步不一致、不可靠、或是在事件追溯复杂度为 n² 的迷宫中白费时间。
（也即，无论是从哪个视图控制器发起的 对某个共享状态改变的请求，状态最终的改变 都由 作为唯一可信源的 单例或 SharedViewModel 在其内部统一决策，并一对多地通知改变）

并且，这种承上启下的方式，使得单向依赖成为可能：单例无需通过 Java Interface 回调通知视图控制器，从而规避了视图控制器 被生命周期更长的单例 依赖 所埋下的内存泄漏的隐患。

1.规避 为监听状态 而 注入视图控制器 的做法
比如activity监听presenter的某一个状态，这时候需要将activity注册到presenter里面，这就埋下了内存泄漏的隐患。

Lifecycle 的存在，主要是为了解决 生命周期管理 的一致性问题。
LiveData 的存在，主要是为了帮助 新手老手 都能不假思索地 遵循 通过唯一可信源分发状态 的标准化开发理念，从而在快速开发过程中 规避一系列 难以追溯、难以排查、不可预期 的问题。
ViewModel 的存在，主要是为了解决 状态管理 和 页面通信 的问题。DataBinding 的存在，主要是为了解决 视图调用 的一致性问题。
它们的存在 大都是为了 在软件工程的背景下 解决一致性的问题、将容易出错的操作在后台封装好，方便使用者快速、稳定、不产生预期外错误地编码。